import type { OBSScene, OBSSource, OBSStreamStatus, OBSRecordStatus, OBSVideoSettings, ChatMessage, CatppuccinAccentColorName, CatppuccinSecondaryAccentColorName, CatppuccinChatBubbleColorName } from '../types';
import type { ObsAction } from '../types/obsActions';
import type { AutomationRule } from '../types/automation';
import type { OBSWebSocketService } from '../services/obsService';
import type { StreamerBotService } from '../services/streamerBotService';
export interface AppState {
    isConnected: boolean;
    isConnecting: boolean;
    connectError: string | null;
    streamerName: string | null;
    scenes: OBSScene[];
    currentProgramScene: string | null;
    sources: OBSSource[];
    streamStatus: OBSStreamStatus | null;
    recordStatus: OBSRecordStatus | null;
    videoSettings: OBSVideoSettings | null;
    obsStats: any | null;
    obsHotkeys: any[] | null;
    obsLogFiles: any[] | null;
    obsServiceInstance: OBSWebSocketService | null;
    geminiMessages: ChatMessage[];
    geminiApiKey: string;
    isGeminiClientInitialized: boolean;
    geminiInitializationError: string | null;
    userDefinedContext: string[];
    automationRules: AutomationRule[];
    streamerBotServiceInstance: StreamerBotService | null;
    userSettings: {
        flipSides: boolean;
        autoApplySuggestions: boolean;
        extraDarkMode: boolean;
        customChatBackground: string;
        bubbleFillOpacity: number;
        backgroundOpacity: number;
        chatBackgroundBlendMode: string;
        chatBubbleBlendMode: string;
        theme: {
            accent: CatppuccinAccentColorName;
            secondaryAccent: CatppuccinSecondaryAccentColorName;
            userChatBubble: CatppuccinChatBubbleColorName;
            modelChatBubble: CatppuccinChatBubbleColorName;
        };
    };
    musicSession: any | null;
    isMusicPlaying: boolean;
    currentMusicPrompt: string;
    audioContext: AudioContext | null;
    audioQueue: AudioBuffer[];
    isQueuePlaying: boolean;
    mediaStreamDest: MediaStreamAudioDestinationNode | null;
    audioDevices: MediaDeviceInfo[];
    selectedAudioOutputId: string;
    audioPermissionGranted: boolean;
    isPlayerVisible: boolean;
    activeAudioSource: {
        type: 'tts' | 'music';
        prompt?: string;
        url?: string;
    } | null;
    actions: {
        setMusicPrompt: (prompt: string) => void;
        setActiveAudioSource: (source: {
            type: 'tts' | 'music';
            prompt?: string;
            url?: string;
        } | null) => void;
        setConnecting: () => void;
        setConnected: (obsData: {
            scenes: OBSScene[];
            currentProgramScene: string | null;
            sources: OBSSource[];
            streamStatus: OBSStreamStatus | null;
            recordStatus: OBSRecordStatus | null;
            videoSettings: OBSVideoSettings | null;
            streamerName: string | null;
        }) => void;
        setDisconnected: (error?: string | null) => void;
        addMessage: (message: Omit<ChatMessage, 'id' | 'timestamp'>) => void;
        replaceMessage: (messageId: string, newMessage: Omit<ChatMessage, 'id' | 'timestamp'>) => void;
        setGeminiApiKey: (key: string) => void;
        setStreamerName: (name: string | null) => void;
        setGeminiClientInitialized: (initialized: boolean) => void;
        setGeminiInitializationError: (error: string | null) => void;
        addToUserDefinedContext: (context: string) => void;
        removeFromUserDefinedContext: (context: string) => void;
        clearUserDefinedContext: () => void;
        toggleFlipSides: () => void;
        toggleAutoApplySuggestions: () => void;
        toggleExtraDarkMode: () => void;
        setCustomChatBackground: (background: string) => void;
        setBubbleFillOpacity: (opacity: number) => void;
        setBackgroundOpacity: (opacity: number) => void;
        setChatBackgroundBlendMode: (mode: string) => void;
        setChatBubbleBlendMode: (mode: string) => void;
        setThemeColor: (type: 'accent' | 'secondaryAccent' | 'userChatBubble' | 'modelChatBubble', color: any) => void;
        setObsServiceInstance: (instance: OBSWebSocketService | null) => void;
        updateOBSData: (data: Partial<{
            scenes: OBSScene[];
            currentProgramScene: string | null;
            sources: OBSSource[];
            streamStatus: OBSStreamStatus | null;
            recordStatus: OBSRecordStatus | null;
            videoSettings: OBSVideoSettings | null;
        }>) => void;
        handleObsAction: (action: ObsAction | ObsAction[]) => Promise<{
            success: boolean;
            message: string;
            error?: string;
        }>;
        addAutomationRule: (rule: AutomationRule) => void;
        updateAutomationRule: (id: string, updates: Partial<AutomationRule>) => void;
        deleteAutomationRule: (id: string) => void;
        toggleAutomationRule: (id: string) => void;
        setStreamerBotServiceInstance: (instance: StreamerBotService | null) => void;
        onSendToGeminiContext: (contextText: string) => void;
        getStats: () => Promise<void>;
        getHotkeys: () => Promise<void>;
        getLogFiles: () => Promise<void>;
        uploadLog: () => Promise<{
            success: boolean;
            url?: string;
            message: string;
        }>;
        initializeAudioContext: () => void;
        startMusicGeneration: (prompt: string, config: any) => Promise<void>;
        addAudioChunk: (pcm: ArrayBuffer) => void;
        playFromQueue: () => void;
        pauseMusic: () => void;
        resumeMusic: () => void;
        stopMusic: () => void;
        loadAudioDevices: () => Promise<void>;
        setAudioOutputDevice: (deviceId: string) => void;
    };
}
export declare const useAppStore: import("zustand").UseBoundStore<import("zustand").StoreApi<AppState>>;
